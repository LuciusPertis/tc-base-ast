## Tiger runtime library ------------------------------------------------------
# Based on code taken from:
# http://www.math.tau.ac.il/~nurr/courses/compile99/runtime.s
#
# entry point in SPIM: 0x004000dc
# main then jumps to tc_main generated by the compiler.
#

## Routine: alloc ------------------------------------------
# Makes sure the allocation is aligned on 4.
# This routine explicitly preserves $t0 to $t7 and $a0-$a3.
# $a0 holds the size of memory wanted.
	.text
alloc:
	## $t9 holds wanted memory size
	move	$t9, $a0
	## Check that $a0 is a multiple of 4
	li	$t8, 4
	remu	$t8, $a0, $t8
	beq	$zero, $t8, L_alloc_sbrk
	## Force $a0 to be a multiple of 4
	sub	$a0, $a0, $t8
	addi	$a0, $a0, 4
L_alloc_sbrk:
	## Call sbrk (alloc $a0 bytes)
	li	$v0, 0x33
	syscall			; malloc
	## Restore original memory size
	move	$a0, $t9

	## $a0 holds original memory size, $v0 holds allocated memory offset
	jr	$ra


## Routine: malloc -----------------------------------------
# Call alloc and initialize allocated memory to 0.
# $a0 holds the size of memory wanted.
	.text
tc_malloc:
	## Call alloc (alloc $a0 bytes)
	move	$t1, $ra		# Save return address in $t1
	jal	alloc
	## Fill allocated memory with zeros
	move	$a2, $v0		# $a2 points to allocated memory
	j	Lmalloc_zend
Lmalloc_zbegin:
	sw	$zero, ($a2)
	addi	$a0, $a0, -4
	addi	$a2, $a2, 4		# Next word
Lmalloc_zend:
	bgtz	$a0, Lmalloc_zbegin	# Loop until end of allocated memory

	## $v0 holds allocated and nulled memory offset
	jr	$t1


## Routine: exit -------------------------------------------
# Halt execution
	.text
tc_exit:
	## Call system exit
	li	$v0, 0x06
	syscall			; exit


## Routine: init_array -------------------------------------
# $a0 holds the size of the array
# $a1 holds initial value
	.text
tc_init_array:
	## Call sbrk
	sll	$a0, $a0, 2		# Each element is 4 bytes long
	li	$v0, 0x33
	syscall			; malloc
	## Fill allocated memory with value in $a1
	move	$a2, $v0		# $a2 points to allocated memory
	j	Linit_array_vend
Linit_array_vbegin:
	sw	$a1, ($a2)
	addi	$a0, $a0, -4
	add	$a2, $a2, 4		# Next word
Linit_array_vend:
	bgtz	$a0, Linit_array_vbegin	# Loop until end of allocated memory

	## $v0 holds allocated and initialized memory offset
	jr	$ra


## Routine: strcmp -----------------------------------------
# Compare string $a0 with string $a1 (normalize result to -1, 0, +1)
  # FIXME: Some code was deleted here.

## Routine: streq ------------------------------------------
# Compare string $a0 with string $a1 for equality (normalize result to 0, +1)
  # FIXME: Some code was deleted here.

## Routine: print ------------------------------------------
# Print the string $a0
	.text
tc_print:
	lw	$a2, ($a0)
	addi	$a1, $a0, 4
	li	$a0, 1
	li	$v0, 0x03
	syscall			; write
	## Content of $v0 is undetermined
	jr	$ra


## Routine: print_err --------------------------------------
# Print the string $a0 on stderr
	.text
tc_print_err:
	lw	$a2, ($a0)
	addi	$a1, $a0, 4
	li	$a0, 2
	li	$v0, 0x03
	syscall			; write
	## Content of $v0 is undetermined
	jr	$ra


## Routine: print_int --------------------------------------
# Print the integer $a0
  # FIXME: Some code was deleted here.

## Routine flush -------------------------------------------
# Nothing to do
	.text
tc_flush:
	jr	$ra


## Routine: main -------------------------------------------
	.data
	.word  0			# Align
Runtconsts:
	.space 2048
Lruntempty:
	.word 0

	.text

# 0x004000dc
# Routine main
main:
	li	$a0, 0
	la	$a1, Runtconsts
	li	$a2, 1
Lrunt20:
	sw	$a2, ($a1)
	sb	$a0, 4($a1)
	addiu	$a1, $a1, 8
	addiu	$a0, $a0, 1
	slti	$a3, $a0, 256
	bne	$zero, $a3, Lrunt20
	move	$fp, $sp
	li	$a0, 0
	jal	tc_main
	move	$s0, $v0   # save the return value
	li	$a0, 0	   # exit sucessfully
	li	$v0, 0x06
	syscall			; exit

## Routine: ord --------------------------------------------
# Compute ascii value of the first character of string $a0
	.text
tc_ord:
	## Return -1 on empty string
	lw	$a1, ($a0)		# $a1 holds the size of $a0
	## If string $a0 is empty, return -1
	li	$v0, -1
	beq	$zero, $a1, Lord_end
	## Else return first char of $a0 into $v0
	lbu	$v0, 4($a0)
Lord_end:
	jr	$ra


## Routine: chr --------------------------------------------
# Return a one-character string which ascii value is $a0
	.data
Lchr_except_msg:
	.ascii "chr: character out of range\n"
Lchr_except_msg_end:

	.text
tc_chr:
	## Check range of $a0
	blt	$a0, $zero, Lchr_except	# Raise exception on ascii code < 0
	li	$a1, 256
	bge	$a0, $a1, Lchr_except	# Raise exception on ascii code >= 256
	## Return the constant string
	la	$v0, Runtconsts
	sll	$a0, $a0, 3
	add	$v0, $v0, $a0

	## $v0 holds the address of a constant string
	jr	$ra

Lchr_except:
	## Runtime failure.
	li	$a0, 2
	la	$a1, Lchr_except_msg
	li	$a2, Lchr_except_msg_end - Lchr_except_msg
	li	$v0, 0x03
	syscall			; write
	li	$a0, 120
	li	$v0, 0x06
	syscall			; exit


## Routine: size -------------------------------------------
# Return size of string $a0
	.text
tc_size:
	lw	$v0, ($a0)		# $v0 holds the size of $a0
	jr	$ra


## Routine: substring --------------------------------------
# Return string $a0 extracted from $a1 for $a2 characters
	.data
Lsubstring_except_msg:
	.ascii "substring: arguments out of bounds\n"
Lsubstring_except_msg_end:
  # FIXME: Some code was deleted here.

## Routine: concat -----------------------------------------
# Concatenate string $a0 with string $a1
tc_concat:
	## Compute sizes
	lw	$t0, ($a0)		# $t0 holds the size of $a0
	lw	$t1, ($a1)		# $t1 holds the size of $a1
	## Check simple cases (empty string)
	beq	$zero, $t0, Lconcat_ret_snd
	beq	$zero, $t1, Lconcat_ret_fst
	## Compute start address of characters
	addiu	$t2, $a0, 4		# $t2 holds start of $a0 chars
	addiu	$t3, $a1, 4		# $t3 holds start of $a1 chars

	## Compute resulting string size
	add	$t4, $t0, $t1
	## Keep a room for the size and the additional `0' required by print(?)
	addiu	$a0, $t4, 5
	## Call alloc
	move	$t6, $ra		# Save caller (return) address
	jal	alloc

	## Fill new string structure
	addiu	$t5, $v0, 4		# $t5 holds start of new chars
	sw	$t4, ($v0)		# $t4 holds size of new string
Lconcat_fst:
  # FIXME: Some code was deleted here (Copy first string $a0 into new string).
Lconcat_snd:
  # FIXME: Some code was deleted here (Copy second string $a1 into new string).

	## Result string is $v0
	jr	$t6

Lconcat_ret_fst:
	## Second string is empty, return first
	move	$v0, $a0
	jr	$ra
Lconcat_ret_snd:
	## First string is empty, return second
	move	$v0, $a1
	jr	$ra


## Routine: _not -------------------------------------------
# Logical negation
	.text
tc_not:
	beq	$a0, $zero, L_not_1
	li	$v0, 0
	jr	$ra
L_not_1:
	li	$v0, 1
	jr	$ra


## Routine: getchar ----------------------------------------
	.data
getchar_buffer_offset:
	.word	0
getchar_buffer_left:
	.word	0

getchar_buffer:
	.space	200
getchar_buffer_end:

getchar_string:
	.word	1
	.space	4

	.text
tc_getchar:
	la	$t0, getchar_buffer_left
	lw	$t1, ($t0)

	bne	$zero, $t1, Lgetchar_ret

Lgetchar_fill_buffer:
	move	$a0, $0
	la	$a1, getchar_buffer
	li	$a2, getchar_buffer_end - getchar_buffer
	li	$v0, 0x02
	syscall			; read

	bltz	$v0, Lgetchar_eof

	la	$t0, getchar_buffer_offset
	sw	$0, ($t0)

	la	$t0, getchar_buffer_left
	move	$t1, $v0

Lgetchar_ret:
	# $t0 = getchar_buffer_left
	# $t1 = *getchar_buffer_left

	sub	$t1, $t1, 1
	sw	$t1, ($t0)

	# Hard call to tc_chr
	la	$t0, getchar_buffer_offset
	lw	$t1, ($t0)
	add	$t1, $t1, 1
	sw	$t1, ($t0)

	la	$t0, getchar_buffer - 1
	add	$t1, $t1, $t0

	lbu	$a0, ($t1)

	j	tc_chr

Lgetchar_eof:
	la	$v0, Lruntempty
	jr	$ra

## End of runtime -------------------------------------------------------------
